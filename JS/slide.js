class Slider{constructor({element:e,elements:t,titles:s,numbers:i}){this.element=e,this.elements=[...t],this.titles=[...s],this.scroll={ease:.1,current:0,target:0,last:0,speed:0},this.touch={start:0,current:0},this.isDragging=!1,this.SliderHeight=this.element.clientHeight,this.SlideHeight=this.elements[0].clientHeight,this.wrapHeight=this.SliderHeight*this.elements.length,this.handleOnCheck=_.debounce(this.onCheck.bind(this),100),this.dispose(0),this.addEvents(),this.render()}lerp(e,t,s){return(1-s)*e+s*t}dispose(e){gsap.set(this.elements,{y:t=>t*this.SlideHeight+e,modifiers:{y:e=>{let t=gsap.utils.wrap(-this.SlideHeight,this.wrapHeight-this.SlideHeight,parseInt(e));return`${t}px`}}})}handleMouseWheel(e){this.scroll.target-=2*e.deltaY,this.handleOnCheck()}handleTouchStart(e){this.touch.start=e.clientY||e.touches[0].clientY,this.isDragging=!0,this.element.classList.add("is-dragging")}handleTouchMove(e){this.isDragging&&(this.touch.current=e.clientY||e.touches[0].clientY,this.scroll.target+=(this.touch.current-this.touch.start)*4,this.touch.start=this.touch.current)}handleTouchEnd(){this.isDragging=!1,this.element.classList.remove("is-dragging"),this.handleOnCheck()}addEvents(){this.element.addEventListener("wheel",this.handleMouseWheel.bind(this),{passive:!0}),this.element.addEventListener("touchstart",this.handleTouchStart.bind(this),{passive:!0}),this.element.addEventListener("touchmove",this.handleTouchMove.bind(this),{passive:!0}),this.element.addEventListener("touchend",this.handleTouchEnd.bind(this),{passive:!0}),this.element.addEventListener("mousedown",this.handleTouchStart.bind(this),{passive:!0}),this.element.addEventListener("mousemove",this.handleTouchMove.bind(this),{passive:!0}),this.element.addEventListener("mouseup",this.handleTouchEnd.bind(this),{passive:!0}),this.element.addEventListener("selectstart",()=>!1),window.addEventListener("resize",this.onResize.bind(this))}onCheck(){let e=Math.round(Math.abs(this.scroll.target)/this.SlideHeight),t=this.SlideHeight*e;this.scroll.target<0?gsap.to(this.scroll,{target:-t,duration:.5,ease:"elastic.out(1, 1)"}):gsap.to(this.scroll,{target:t,duration:.5,ease:"elastic.out(1, 1)"})}onResize(){this.SliderHeight=this.element.clientHeight,this.SlideHeight=this.elements[0].clientHeight+100,this.wrapHeight=this.SliderHeight*this.elements.length}render(){this.scroll.current=this.lerp(this.scroll.current,this.scroll.target,this.scroll.ease),this.dispose(this.scroll.current),this.scroll.speed=this.scroll.current-this.scroll.last,this.scroll.last=this.scroll.current,this.currentIndex=Math.round(Math.abs(this.scroll.current)/this.SlideHeight)%this.elements.length,gsap.set(this.titles,{y:e=>e*this.SlideHeight+this.scroll.current,modifiers:{y:e=>{let t=gsap.utils.wrap(-this.SlideHeight,this.wrapHeight-this.SlideHeight,parseInt(e));return`${t}px`}}}),requestAnimationFrame(this.render.bind(this))}}function map(e,t,s,i,h){return gsap.utils.mapRange(t,s,i,h,e)}const _SHADERS={vertex:document.querySelector("#vertex").textContent,fragment:document.querySelector("#fragment").textContent};class PlaneSmooth{constructor({element:e,scene:t}){this.element=e,this.scene=t,this.image=this.element.querySelector("img"),this.vert=_SHADERS.vertex,this.frag=_SHADERS.fragment,this.sizes=new THREE.Vector2(0,0),this.offset=new THREE.Vector2(0,0),this.clock=new THREE.Clock,this.mouse={current:new THREE.Vector2(0,0),follow:new THREE.Vector2(0,0),prev:new THREE.Vector2(0,0),speed:0,targetSpeed:0},this.createMesh(),this.mouseMove()}mouseMove(){window.addEventListener("mousemove",e=>{this.mouse.current.x=e.clientX/window.innerWidth,this.mouse.current.y=1-e.clientY/window.innerHeight}),this.element.addEventListener("mouseenter",()=>{gsap.to(this.element,{rotate:2.5})}),this.element.addEventListener("mouseleave",()=>{gsap.to(this.element,{rotate:0})})}getDimension(){let{width:e,height:t,top:s,left:i}=this.image.getBoundingClientRect();this.sizes.set(e,t),this.offset.set(i-window.innerWidth/2+e/2,-s+window.innerHeight/2-t/2)}createMesh(){this.geometry=new THREE.PlaneGeometry(1,1,100,100),this.imageTexture=new THREE.TextureLoader().load(this.image.src),this.imageTexture.minFilter=THREE.LinearFilter,this.imageTexture.generateMipmaps=!1,this.uniforms={uTexture:{value:this.imageTexture},uOffset:{value:new THREE.Vector2(0,0)},uAlpha:{value:1},uTime:{value:0},uPlaneSizes:{value:[0,0]},uImageSizes:{value:[0,0]},uViewportSizes:{value:[window.innerWidth,window.innerHeight]},uZoom:{value:.85},uParallax:{value:0},uProgress:{value:0},uResolution:{value:new THREE.Vector2(window.innerWidth/2,window.innerHeight/2)},uQuadSize:{value:new THREE.Vector2(300,300)},uTextureSize:{value:new THREE.Vector2(100,100)},uCorners:{value:new THREE.Vector4(0,0,0,0)},uStrength:{value:0},uMouse:{value:new THREE.Vector2(-10,-10)},uVelo:{value:0},uMouseSize:{value:new THREE.Vector2(1,window.innerHeight/window.innerWidth)}},this.uniforms.uniformsNeedUpdate=!0,this.material=new THREE.ShaderMaterial({uniforms:this.uniforms,vertexShader:this.vert,fragmentShader:this.frag,transparent:!0,side:THREE.DoubleSide}),this.mesh=new THREE.Mesh(this.geometry,this.material),this.getDimension(),this.mesh.position.set(this.offset.x,this.offset.y,this.z),this.mesh.scale.set(this.sizes.x,this.sizes.y,1),this.scene.add(this.mesh)}getSpeed(){this.speed=Math.sqrt((this.mouse.prev.x-this.mouse.current.x)**2+(this.mouse.prev.y-this.mouse.current.y)**2),this.mouse.targetSpeed-=.1*(this.mouse.targetSpeed-this.speed),this.mouse.follow.x-=.1*(this.mouse.follow.x-this.mouse.current.x),this.mouse.follow.y-=.1*(this.mouse.follow.y-this.mouse.current.y),this.mouse.prev.x=this.mouse.current.x,this.mouse.prev.y=this.mouse.current.y}render(e){this.scroll=e,this.scrollSpeed=(this.scroll.target-this.scroll.current)*.001,this.uniforms.uStrength.value=Math.abs(this.scrollSpeed);let t=(this.mesh.position.y-this.scroll.current/100)*.05;this.uniforms.uParallax.value=map(t,-1.1,1.1,-.005,.005),this.uniforms.uPlaneSizes.value=[this.mesh.scale.x,this.mesh.scale.y],this.getDimension(),this.getSpeed(),this.mesh.position.set(this.offset.x,this.offset.y,this.z),this.mesh.scale.set(this.sizes.x,this.sizes.y,1),this.uniforms.uOffset.value.set(0,-this.scrollSpeed),this.uniforms.uImageSizes.value=[this.image.naturalWidth,this.image.naturalHeight,],this.uniforms.uMouse.value=this.mouse.follow,this.uniforms.uVelo.value=Math.min(this.mouse.targetSpeed,.05),this.mouse.targetSpeed*=.999,this.time=this.clock.getElapsedTime(),this.uniforms.uTime.value=this.time}}class Webgl{constructor({canvas:e,elements:t,scroll:s}){this.canvas=e,this.elements=[...t],this.scroll=s,this.meshItems=[],this.createSetup(),this.createMeshItems(),this.render()}get viewport(){let e=window.innerWidth,t=window.innerHeight;return{width:e,height:t,aspectRatio:e/t}}createSetup(){this.scene=new THREE.Scene,this.camera=null,this.renderer=new THREE.WebGL1Renderer({canvas:this.canvas,antialias:!0,alpha:!0}),this.renderer.setClearColor(0,0),this.perspective=1e3,this.fov=180*(2*Math.atan(window.innerHeight/2/this.perspective))/Math.PI,this.camera=new THREE.PerspectiveCamera(this.fov,this.viewport.aspectRatio,1,this.perspective),this.camera.position.set(0,0,this.perspective),this.renderer.sortObjects=!1,this.renderer.outputEncoding=THREE.sRGBEncoding,this.renderer.setSize(this.viewport.width,this.viewport.height),this.renderer.setPixelRatio(window.devicePixelRatio),window.addEventListener("resize",this.onWindowResize.bind(this),!1)}onWindowResize(){this.camera.aspect=this.viewport.aspectRatio,this.camera.updateProjectionMatrix(),this.renderer.setSize(this.viewport.width,this.viewport.height)}createMeshItems(){this.elements.forEach(e=>{let t=new PlaneSmooth({element:e,scene:this.scene});this.meshItems.push(t)})}render(){for(let e=0;e<this.meshItems.length;e++)this.meshItems[e].render(this.scroll);this.renderer.render(this.scene,this.camera),requestAnimationFrame(this.render.bind(this))}}const select=e=>document.querySelector(e),selectAll=e=>document.querySelectorAll(e),slider=select(".slider"),slides=selectAll(".slider-slide"),titles=selectAll(".slider-title"),canvas=select(".webgl-canvas"),loader=select(".loader");imagesLoaded(document.body,()=>{console.log("images loaded"),loader.classList.add("is-loaded");let e=new Slider({element:slider,elements:slides,titles:titles});new Webgl({canvas:canvas,elements:slides,scroll:e.scroll}),setTimeout(()=>{loader.remove()},1e3)});